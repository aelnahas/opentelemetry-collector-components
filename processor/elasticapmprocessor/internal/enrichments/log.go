// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package enrichments // import "github.com/elastic/opentelemetry-collector-components/processor/elasticapmprocessor/internal/enrichments"

import (
	"crypto/md5"
	"encoding/hex"
	"io"

	"github.com/elastic/opentelemetry-collector-components/internal/elasticattr"
	"github.com/elastic/opentelemetry-collector-components/processor/elasticapmprocessor/internal/enrichments/attribute"
	"github.com/elastic/opentelemetry-collector-components/processor/elasticapmprocessor/internal/enrichments/config"
	"github.com/elastic/opentelemetry-collector-components/processor/elasticapmprocessor/internal/enrichments/mobile"
	"github.com/elastic/opentelemetry-collector-components/processor/elasticapmprocessor/internal/routing"
	"go.opentelemetry.io/collector/pdata/plog"
)

const (
	// emptyExceptionMsg is used to replace an empty exception message only in ecs mode.
	emptyExceptionMsg = "[EMPTY]"
)

func EnrichLog(resourceAttrs map[string]any, log plog.LogRecord, cfg config.Config) {
	if cfg.Log.ProcessorEvent.Enabled {
		attribute.PutStr(log.Attributes(), elasticattr.ProcessorEvent, "log")
	}
	eventName, ok := getEventName(log)
	if ok {
		ctx := mobile.EventContext{
			ResourceAttributes: resourceAttrs,
			EventName:          eventName,
		}
		mobile.EnrichLogEvent(ctx, log)
	}

	if routing.IsErrorEvent(log.Attributes()) {
		EnrichLogError(log, cfg)
	}
}

// getEventName returns the event name from the log record.
// If the event name is not set, it returns an empty string.
func getEventName(logRecord plog.LogRecord) (string, bool) {
	if logRecord.EventName() != "" {
		return logRecord.EventName(), true
	}
	attributeValue, ok := logRecord.Attributes().Get("event.name")
	if ok {
		return attributeValue.AsString(), true
	}
	return "", false
}

// EnrichLogError enriches the log record with error attributes.
// exists early if the are no exceptions or error messages.
func EnrichLogError(logRecord plog.LogRecord, cfg config.Config) {
	attributes := logRecord.Attributes()
	ec := getErrorEventContext(attributes)

	if ec.exceptionType == "" && ec.exceptionMessage == "" {
		return
	}

	if ec.exceptionMessage == "" {
		ec.exceptionMessage = emptyExceptionMsg
	}

	if cfg.Log.ErrorID.Enabled {
		if id, err := attribute.NewErrorID(); err == nil {
			attribute.PutStr(attributes, elasticattr.ErrorID, id)
		}
	}

	if cfg.Log.ErrorExceptionHandled.Enabled {
		attribute.PutBool(attributes, elasticattr.ErrorExceptionHandled, !ec.exceptionEscaped)
	}
	if cfg.Log.ErrorExceptionMessage.Enabled {
		attribute.PutStr(attributes, elasticattr.ECSErrorExceptionMessage, ec.exceptionMessage)
	}
	if cfg.Log.ErrorExceptionType.Enabled && ec.exceptionType != "" {
		attribute.PutStr(attributes, elasticattr.ECSErrorExceptionType, ec.exceptionType)
	}
	if cfg.Log.ErrorStackTrace.Enabled && ec.exceptionStacktrace != "" {
		attribute.PutStr(attributes, elasticattr.ErrorStackTrace, ec.exceptionStacktrace)
	}

	// Note: this is a fallback to set the error.grouping_key attribute.
	// For mobile crash events, the error.grouping_key is set by the mobile.EnrichLogEvent function.
	if cfg.Log.ErrorGroupingKey.Enabled {
		if key := getGenericErrorGroupingKey(ec); key != "" {
			attribute.PutStr(attributes, elasticattr.ErrorGroupingKey, key)
		}
	}

	if cfg.Log.TimestampUs.Enabled {
		ts := logRecord.Timestamp()
		if ts == 0 {
			ts = logRecord.ObservedTimestamp()
		}
		attribute.PutInt(attributes, elasticattr.TimestampUs, attribute.ToTimestampUS(ts))
	}

}

func getGenericErrorGroupingKey(ec errorEventContext) string {
	hash := md5.New()
	if ec.exceptionType != "" {
		_, _ = io.WriteString(hash, ec.exceptionType)
	}
	if ec.exceptionMessage != "" {
		_, _ = io.WriteString(hash, ec.exceptionMessage)
	}
	if ec.exceptionStacktrace != "" {
		_, _ = io.WriteString(hash, ec.exceptionStacktrace)
	}
	return hex.EncodeToString(hash.Sum(nil))
}
